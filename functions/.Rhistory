match_winner <- 'P2'
}
return(list(match_winner,match_df))
}
# define play_set
play_set <- function(arg_set_first_server,arg_set_p1_serve_pct,arg_set_p2_serve_pct,arg_set_inherit = FALSE,arg_set_inherited_score = NULL) {
# initial values
set_over <- FALSE
p1_games <- 0
p2_games <- 0
tiebreak <- FALSE
current_server <- arg_set_first_server
set_most_recent_server <- current_server
inherit_game <- FALSE
# inherit
if (arg_set_inherit) {
inherited_score <- convert_score(arg_set_inherited_score)
p1_games <- inherited_score[["p1_games"]]
p2_games <- inherited_score[["p2_games"]]
tiebreak <- inherited_score[["tiebreak_ind"]]
current_server <- arg_set_inherited_server
inherit_game <- TRUE
}
# this function additionally outputs a data frame with the results of each point
set_df <- data.frame(
game_number <- numeric(),
point_number <- numeric(),
server <- character(),
winner <- character(),
tiebreak_ind <- logical()
)
# play games until the set is over
while(set_over == FALSE) {
if (!tiebreak) {
# play a game
game_object <- play_game(arg_game_server = current_server, arg_game_serve_pct = ifelse(current_server == 'P1', arg_set_p1_serve_pct, arg_set_p2_serve_pct), arg_game_inherit = inherit_game, arg_game_inherited_score = arg_set_inherited_score)
# immediately switch off the inherited switch, so that any future games start at 0-0
inherit_game <- FALSE
# retrieve the winner of the game
game_winner <- game_object[[1]]
# retrieve the game_df object that shows the points played in the game just played
game_df <- game_object[[2]]
# update the most recent server variable
set_most_recent_server <- current_server
# award winner a game
if (game_winner == 'P1') {
p1_games <- p1_games + 1
} else {
p2_games <- p2_games + 1
}
# check if set is over
if((p1_games == 6 & p2_games <= 4) | (p2_games == 6 & p1_games <= 4) | p1_games == 7 | p2_games == 7) {
set_over <- TRUE
}
# update the set_df data frame
game_df['game_number'] <- p1_games + p2_games
game_df['tiebreak_ind'] <- tiebreak
set_df <- rbind(
set_df,
game_df
)
# swap server
current_server = ifelse(current_server == 'P1','P2','P1')
# check if tiebreak needed
if (p1_games == 6 & p2_games == 6) {
tiebreak <- TRUE
}
}
if(tiebreak) {
game_object <- play_tiebreak(arg_tiebreak_first_server = current_server,arg_tiebreak_p1_serve_pct = arg_set_p1_serve_pct,arg_tiebreak_p2_serve_pct = arg_set_p2_serve_pct,arg_tiebreak_inherit = inherit_game,arg_tiebreak_inherited_score = arg_set_inherited_score)
# immediately switch off the inherited switch
inherit_game <- FALSE
game_winner <- game_object[[1]]
game_df <- game_object[[2]]
set_over <- TRUE
# award winner of tiebreak a game
if (game_winner == 'P1') {
p1_games <- p1_games + 1
} else {
p2_games <- p2_games + 1
}
# update set_df data frame
game_df['game_number'] <- p1_games + p2_games
game_df['tiebreak_ind'] <- tiebreak
set_df <- rbind(
set_df,
game_df
)
}
}
if (p1_games > p2_games) {
set_winner <- 'P1'
} else {
set_winner <- 'P2'
}
return(list(set_winner,set_df,set_most_recent_server))
}
# define play_game
play_game <- function(arg_game_server,arg_game_serve_pct,arg_game_inherit = FALSE,arg_game_inherited_score = NULL) {
# initial values
p1_points <- 0
p2_points <- 0
current_server <- arg_game_server
game_over <- FALSE
# inherit
if (arg_game_inherit) {
inherited_score <- convert_score(arg_game_inherited_score)
p1_points <- inherited_score[["p1_points"]]
p2_points <- inherited_score[["p2_points"]]
}
# this function additionally outputs a data frame with a record of points and their outcomes
game_df <- data.frame(
point_number = numeric(),
server = character(),
winner = character()
)
# play points until the game is over
while(game_over == FALSE) {
# play a point
point_winner <- play_point(arg_point_server = current_server, arg_point_serve_pct = arg_game_serve_pct)
# increment points of the winner of the point just played
if (point_winner == 'P1') {
p1_points <- p1_points + 1
} else {
p2_points <- p2_points + 1
}
if (p1_points == 4 & p2_points == 4) {
p1_points <- 3
p2_points <- 3
}
# add a row to the game_df data frame
game_df <- rbind(
game_df,
data.frame(point_number = p1_points + p2_points, server = arg_game_server, winner = point_winner)
)
# check if the game is over
if ((p1_points >= 4 | p2_points >= 4) &
(abs(p1_points - p2_points) >= 2)) {
game_over <- TRUE
}
}
if (p1_points > p2_points) {
game_winner <- 'P1'
} else {
game_winner <- 'P2'
}
return(list(game_winner,game_df))
}
# define play_point
play_point <- function(arg_point_server, arg_point_serve_pct) {
# generate random number
random_number <- runif(1)
# determine winner of point
if (arg_point_serve_pct > random_number) {
if (arg_point_server == 'P1') {
return('P1')
} else if (arg_point_server == 'P2') {
return('P2')
}
} else {
if (arg_point_server == 'P1') {
return('P2')
} else if (arg_point_server == 'P2') {
return('P1')
}
}
}
play_tiebreak <- function(arg_tiebreak_first_server,arg_tiebreak_p1_serve_pct,arg_tiebreak_p2_serve_pct,arg_tiebreak_inherit=FALSE,arg_tiebreak_inherited_score=NULL) {
# initial values
tiebreak_over <- FALSE
tiebreak_current_server <- arg_tiebreak_first_server
p1_points <- 0
p2_points <- 0
tiebreak_serves_remaining <- 1 # first person to serve only serves once
# inherit
if (arg_tiebreak_inherit) {
inherited_score <- convert_score(arg_tiebreak_inherited_score)
p1_points <- inherited_score[["p1_points"]]
p2_points <- inherited_score[["p2_points"]]
tiebreak_server_points_served <- (sum(p1_points,p2_points)%%2) + 1
}
# this function additionally outputs a data frame with the outcomes of individual points
tiebreak_df <- data.frame(
point_number = numeric(),
server = character(),
winner = character()
)
# play the remainder of the tiebreak
while(tiebreak_over == FALSE) {
# play the current server's 2 points
while (tiebreak_serves_remaining > 0) {
# play the first point on this player's server
point_winner <- play_point(arg_point_server = tiebreak_current_server, arg_point_serve_pct = ifelse(tiebreak_current_server == 'P1',arg_tiebreak_p1_serve_pct,arg_tiebreak_p2_serve_pct))
# award point to the winner
if (point_winner == 'P1') {
p1_points <- p1_points + 1
} else {
p2_points <- p2_points + 1
}
# increment the points served by this current server
tiebreak_serves_remaining <- tiebreak_serves_remaining - 1
# update the tiebreak_df object
tiebreak_df <- rbind(
tiebreak_df,
data.frame(point_number = p1_points + p2_points, server = tiebreak_current_server, winner = point_winner)
)
# check if tiebreak should be ended
if ((p1_points >= 7 | p2_points >= 7) & (abs(p1_points - p2_points) > 1)) {
tiebreak_over <- TRUE
break
}
}
# after the first point players get 2 serves each
tiebreak_serves_remaining <- 2
# swap server
tiebreak_current_server <- ifelse(tiebreak_current_server == "P1","P2","P1")
}
# determine who wins the tiebreak
if (p1_points > p2_points) {
tiebreak_winner <- 'P1'
} else {
tiebreak_winner <- 'P2'
}
# return the winner of the tiebreak
return(list(tiebreak_winner,tiebreak_df))
}
# example of a match
play_match(arg_best_of = 3, arg_match_first_server = 'P1', arg_match_p1_serve_pct = 0.9, arg_match_p2_serve_pct = 0.9)[[1]]
rm(list=ls())
library(dplyr);library(lubridate);library(data.table);library(sqldf)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
# output
return(list(winners,results_df))
}
require(data.table);require(lubridate);require(dplyr)
setwd('/Users/williammunn/Documents/Github/tennis/Data/')
# load match data
files <- list.files(pattern="atp_matches_[^_]*.csv")
Data <- do.call("rbind", lapply(files, function(x) fread(x)))
# clean data
Data[,tourney_date := as.Date(as.character(tourney_date) ,format='%Y%m%d', origin = "1900/01/01")]
Data[,`:=`(winner_id = as.character(winner_id),loser_id = as.character(loser_id))]
# dictate what variables get assigned to what data
match.vars <- c('tourney_id','tourney_date','winner_id','loser_id','best_of','score','round','minutes')
stat.vars <- c('tourney_id','winner_id','loser_id','round','w_svpt','w_SvGms','w_1stWon','w_2ndWon','w_bpSaved','w_bpFaced','l_svpt','l_SvGms','l_1stWon','l_2ndWon','l_bpSaved','l_bpFaced')
tourney.vars <- c('tourney_id','tourney_name','tourney_date','surface','draw_size')
seed.vars <- c('tourney_id','winner_id','loser_id','winner_seed','loser_seed','round')
player.vars <- c('winner_id','winner_name','loser_id','loser_name')
# matches
match.data <- Data[!(round %in% c("BR","ER")),.SD,.SDcols = match.vars][,match_id := seq_len(.N)] ; setkey(match.data,round)
sortorderdf <- data.table(round=c("RR","R128","R64","R32","R16","QF","SF","F"),order=1:8) ; setkey(sortorderdf,round)
match.data <- sortorderdf[match.data][order(tourney_id,order)] ; rm(sortorderdf)
match.data[,match_num := seq_len(.N), by = .(tourney_id)]
setkey(match.data,match_id)
# stats per player per match
stat.data <- Data[!(round %in% c("BR","ER")),.SD,.SDcols = stat.vars][,match_id := seq_len(.N)]
setkey(stat.data,match_id)
stat.data[match.data, on = 'match_id', match_num := i.match_num]
stat.data <- rbind(
stat.data[,.(match_id,match_num,tourney_id,round,winner_id,loser_id,player_id=winner_id,svpts=w_svpt,svgms=w_SvGms,svpts_won=w_1stWon+w_2ndWon,bp_faced=w_bpFaced,bp_saved=w_bpSaved)],
stat.data[,.(match_id,match_num,tourney_id,round,winner_id,loser_id,player_id=loser_id,svpts=l_svpt,svgms=l_SvGms,svpts_won=l_1stWon+l_2ndWon,bp_faced=l_bpFaced,bp_saved=l_bpSaved)]
)[,svgms_won := svgms - (bp_faced - bp_saved)]
# tournaments
tourney.data <- Data[,.SD,.SDcols = tourney.vars]
tourney.data <- tourney.data[!duplicated(tourney.data),]
# prepare seedings data
seedings.data <- Data[,.SD,.SDcols = seed.vars]
seedings.data2 <- rbind(
seedings.data[!is.na(winner_seed),.(tourney_id,winner_id,winner_seed)][,.(tourney_id, player_id = winner_id, seed = winner_seed)],
seedings.data[!is.na(loser_seed),.(tourney_id,loser_id,loser_seed)][,.(tourney_id, player_id = loser_id, seed = loser_seed)]
)
seedings.data2 <- seedings.data2[!duplicated(seedings.data2),]
seedings.data <- seedings.data2[order(tourney_id,seed)]
rm(seedings.data2,files,match.vars,stat.vars,seed.vars,tourney.vars)
# prepare player data
player.data <- Data[,.SD,.SDcols = player.vars]
player.data2 <- rbind(
player.data[,.(winner_id,winner_name)][,.(player_id = winner_id, player_name = winner_name)],
player.data[,.(loser_id,loser_name)][,.(player_id = loser_id, player_name = loser_name)])[order(player_id)] %>% distinct()
player.data <- player.data2
rm(player.data2,player.vars)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
print('All data loaded')
View(match.data)
View(tourney.data)
View(player.data)
View(match.data)
rm(list=ls())
round <- 3
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
cat("/014")
cat("\014")
rm(list=ls())
rounds <- 3
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# get some players
x <- snapshot(elo_history,"2019-06-01")
rm(list=ls())
library(dplyr);library(lubridate);library(data.table);library(sqldf)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
# output
return(list(winners,results_df))
}
x <- snapshot(elo_history,"2019-06-01")
View(x)
y <- as.character(x$player_id)
z <- sample(y,size=32,replace=F)
output <- simulate_tournament("2022-01-01",z)[[2]] # full dataset of tournament
# add on player name
player <- player.data
output2 <- sqldf(
"select a.*,
b.player_name as name1,
c.player_name as name2,
d.player_name as winner_name
from output a
left join player b on a.player1 = b.player_id
left join player c on a.player2 = c.player_id
left join player d on a.winner = d.player_id")
View(output2)
View(elo_outcome)
View(elo.calculate.points)
