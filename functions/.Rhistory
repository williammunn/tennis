inherit.set <- FALSE
set.winner <- set.object[[1]]
set.df <- set.object[[2]]
set.last.server <- set.object[[3]]
# swap server, based on who served in the final non-tiebreak game of the previous set
current.server <- ifelse(set.last.server == 'P1','P2','P1')
# increment number of sets played
sets.played <- sets.played + 1
# increment the set winner's count
if (set.winner == 'P1') {
p1.sets <- p1.sets + 1
} else {
p2.sets <- p2.sets + 1
}
# update the match.df object
set.df['set_number'] <- p1.sets + p2.sets
match.df <- rbind(
match.df,
set.df
)
# check if match is over
if (p1.sets == ceiling(arg.best.of/2) | p2.sets == ceiling(arg.best.of/2)) {
match.over <- TRUE
}
}
# determine winner
if (p1.sets > p2.sets) {
match.winner <- 'P1'
} else {
match.winner <- 'P2'
}
return(list(match.winner,match.df))
}
# define play.set
play.set <- function(arg.set.first.server,arg.set.p1.serve.pct,arg.set.p2.serve.pct,arg.set.inherit = FALSE,arg.set.inherited.score = NULL) {
# initial values
set.over <- FALSE
p1.games <- 0
p2.games <- 0
tiebreak <- FALSE
current.server <- arg.set.first.server
set.most.recent.server <- current.server
inherit.game <- FALSE
# inherit
if (arg.set.inherit) {
inherited.score <- convert.score(arg.set.inherited.score)
p1.games <- inherited.score[["p1.games"]]
p2.games <- inherited.score[["p2.games"]]
tiebreak <- inherited.score[["tiebreak.ind"]]
current.server <- arg.set.inherited.server
inherit.game <- TRUE
}
# this function additionally outputs a data frame with the results of each point
set.df <- data.frame(
game_number <- numeric(),
point_number <- numeric(),
server <- character(),
winner <- character(),
tiebreak_ind <- logical()
)
# play games until the set is over
while(set.over == FALSE) {
if (!tiebreak) {
# play a game
game.object <- play.game(arg.game.server = current.server, arg.game.serve.pct = ifelse(current.server == 'P1', arg.set.p1.serve.pct, arg.set.p2.serve.pct), arg.game.inherit = inherit.game, arg.game.inherited.score = arg.set.inherited.score)
# immediately switch off the inherited switch, so that any future games start at 0-0
inherit.game <- FALSE
# retrieve the winner of the game
game.winner <- game.object[[1]]
# retrieve the game.df object that shows the points played in the game just played
game.df <- game.object[[2]]
# update the most recent server variable
set.most.recent.server <- current.server
# award winner a game
if (game.winner == 'P1') {
p1.games <- p1.games + 1
} else {
p2.games <- p2.games + 1
}
# check if set is over
if((p1.games == 6 & p2.games <= 4) | (p2.games == 6 & p1.games <= 4) | p1.games == 7 | p2.games == 7) {
set.over <- TRUE
}
# update the set.df data frame
game.df['game_number'] <- p1.games + p2.games
game.df['tiebreak_ind'] <- tiebreak
set.df <- rbind(
set.df,
game.df
)
# swap server
current.server = ifelse(current.server == 'P1','P2','P1')
# check if tiebreak needed
if (p1.games == 6 & p2.games == 6) {
tiebreak <- TRUE
}
}
if(tiebreak) {
game.object <- play.tiebreak(arg.tiebreak.first.server = current.server,arg.tiebreak.p1.serve.pct = arg.set.p1.serve.pct,arg.tiebreak.p2.serve.pct = arg.set.p2.serve.pct,arg.tiebreak.inherit = inherit.game,arg.tiebreak.inherited.score = arg.set.inherited.score)
# immediately switch off the inherited switch
inherit.game <- FALSE
game.winner <- game.object[[1]]
game.df <- game.object[[2]]
set.over <- TRUE
# award winner of tiebreak a game
if (game.winner == 'P1') {
p1.games <- p1.games + 1
} else {
p2.games <- p2.games + 1
}
# update set.df data frame
game.df['game_number'] <- p1.games + p2.games
game.df['tiebreak_ind'] <- tiebreak
set.df <- rbind(
set.df,
game.df
)
}
}
if (p1.games > p2.games) {
set.winner <- 'P1'
} else {
set.winner <- 'P2'
}
return(list(set.winner,set.df,set.most.recent.server))
}
# define play.game
play.game <- function(arg.game.server,arg.game.serve.pct,arg.game.inherit = FALSE,arg.game.inherited.score = NULL) {
# initial values
p1.points <- 0
p2.points <- 0
current.server <- arg.game.server
game.over <- FALSE
# inherit
if (arg.game.inherit) {
inherited.score <- convert.score(arg.game.inherited.score)
p1.points <- inherited.score[["p1.points"]]
p2.points <- inherited.score[["p2.points"]]
}
# this function additionally outputs a data frame with a record of points and their outcomes
game.df <- data.frame(
point_number = numeric(),
server = character(),
winner = character()
)
# play points until the game is over
while(game.over == FALSE) {
# play a point
point.winner <- play.point(arg.point.server = current.server, arg.point.serve.pct = arg.game.serve.pct)
# increment points of the winner of the point just played
if (point.winner == 'P1') {
p1.points <- p1.points + 1
} else {
p2.points <- p2.points + 1
}
if (p1.points == 4 & p2.points == 4) {
p1.points <- 3
p2.points <- 3
}
# add a row to the game.df data frame
game.df <- rbind(
game.df,
data.frame(point_number = p1.points + p2.points, server = arg.game.server, winner = point.winner)
)
# check if the game is over
if ((p1.points >= 4 | p2.points >= 4) &
(abs(p1.points - p2.points) >= 2)) {
game.over <- TRUE
}
}
if (p1.points > p2.points) {
game.winner <- 'P1'
} else {
game.winner <- 'P2'
}
return(list(game.winner,game.df))
}
# define play.point
play.point <- function(arg.point.server, arg.point.serve.pct) {
# generate random number
random.number <- runif(1)
# determine winner of point
if (arg.point.serve.pct > random.number) {
if (arg.point.server == 'P1') {
return('P1')
} else if (arg.point.server == 'P2') {
return('P2')
}
} else {
if (arg.point.server == 'P1') {
return('P2')
} else if (arg.point.server == 'P2') {
return('P1')
}
}
}
play.tiebreak <- function(arg.tiebreak.first.server,arg.tiebreak.p1.serve.pct,arg.tiebreak.p2.serve.pct,arg.tiebreak.inherit=FALSE,arg.tiebreak.inherited.score=NULL) {
# initial values
tiebreak.over <- FALSE
tiebreak.current.server <- arg.tiebreak.first.server
p1.points <- 0
p2.points <- 0
tiebreak.serves.remaining <- 1 # first person to serve only serves once
# inherit
if (arg.tiebreak.inherit) {
inherited.score <- convert.score(arg.tiebreak.inherited.score)
p1.points <- inherited.score[["p1.points"]]
p2.points <- inherited.score[["p2.points"]]
tiebreak.server.points.served <- (sum(p1.points,p2.points)%%2) + 1
}
# this function additionally outputs a data frame with the outcomes of individual points
tiebreak.df <- data.frame(
point_number = numeric(),
server = character(),
winner = character()
)
# play the remainder of the tiebreak
while(tiebreak.over == FALSE) {
# play the current server's 2 points
while (tiebreak.serves.remaining > 0) {
# play the first point on this player's server
point.winner <- play.point(arg.point.server = tiebreak.current.server, arg.point.serve.pct = ifelse(tiebreak.current.server == 'P1',arg.tiebreak.p1.serve.pct,arg.tiebreak.p2.serve.pct))
# award point to the winner
if (point.winner == 'P1') {
p1.points <- p1.points + 1
} else {
p2.points <- p2.points + 1
}
# increment the points served by this current server
tiebreak.serves.remaining <- tiebreak.serves.remaining - 1
# update the tiebreak.df object
tiebreak.df <- rbind(
tiebreak.df,
data.frame(point_number = p1.points + p2.points, server = tiebreak.current.server, winner = point.winner)
)
# check if tiebreak should be ended
if ((p1.points >= 7 | p2.points >= 7) & (abs(p1.points - p2.points) > 1)) {
tiebreak.over <- TRUE
break
}
}
# after the first point players get 2 serves each
tiebreak.serves.remaining <- 2
# swap server
tiebreak.current.server <- ifelse(tiebreak.current.server == "P1","P2","P1")
}
# determine who wins the tiebreak
if (p1.points > p2.points) {
tiebreak.winner <- 'P1'
} else {
tiebreak.winner <- 'P2'
}
# return the winner of the tiebreak
return(list(tiebreak.winner,tiebreak.df))
}
# example of a match
# play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[2]]
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[2]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
# example of a match
play.match(arg.best.of = 3, arg.match.first.server = 'P1', arg.match.p1.serve.pct = 0.9, arg.match.p2.serve.pct = 0.9)[[1]]
play.point('P1',0.70)
play.point('P1',0.70)
play.point('P1',0.70)
play.point('P1',0.70)
play.point('P1',0.70)
play.point('P1',0.70)
play.point('P1',0.70)
play.point('P1',0.70)
play.tiebreak('P1',0.7,0.6)
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.7,0.6)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.9,0.9)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.99,0.99)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
play.tiebreak('P1',0.5,0.5)[[2]]
rm(list=ls())
library(dplyr);library(lubridate);library(data.table);library(sqldf)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
# output
return(list(winners,results_df))
}
# example of running the function
# get some players
x <- snapshot(elo_history,"2019-06-01")
y <- as.character(x$player_id)
z <- sample(y,size=32,replace=F)
output <- simulate_tournament("2022-01-01",z)[[2]] # full dataset of tournament
View(output)
View(elo_outcome)
for (x in 1:4) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
for (x in 1:4) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
rounds <- 4
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
