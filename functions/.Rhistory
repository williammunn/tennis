players <- unique(c(elo.input.data[['winner_id']],elo.input.data[['loser_id']]))
elo <- rep(1500,length=length(players))
matches <- rep(0,length(players))
# go through match-by-match, updating Elos for each player
output <- apply(
temp,
MARGIN = 1,
function(x) {
# determine indices for winner and loser
winner <- which(players==x[4])
loser <- which(players==x[5])
# calculate winner and loser Elo points
points <- elo.calculate.points(
arg.p1 = x[4],
arg.p2 = x[5],
arg.winner = x[4],
arg.p1.matches = matches[winner],
arg.p2.matches = matches[loser],
arg.prevelo.p1 = elo[winner],
arg.prevelo.p2 = elo[loser]
)
# update matches count
matches[winner] <<- matches[winner] + 1
matches[loser] <<- matches[loser] + 1
# update Elos
elo[winner] <<- points[[1]]
elo[loser] <<- points[[2]]
# output
return(points)
}
)
print("Elos calculated")
# extract values and put these into the data
temp2 <- temp[,`:=`(
winner_elo = unlist(output)[c(TRUE,FALSE)],
loser_elo = unlist(output)[c(FALSE,TRUE)]
)][order(tourney_date,tourney_id,match_num)]
# sadly we do not know the date of each actual match
# this means that the best we can do is do store the
# Elo ratings for each player for the final match of
# each tournament he/she played in
# so we will take this match now
# first we need to convert the data to one row per player/match
temp3 <- rbind(
copy(temp2)[,.(tourney_id,tourney_date,match_num,player_id=winner_id,elo=winner_elo)],
copy(temp2)[,.(tourney_id,tourney_date,match_num,player_id=loser_id,elo=loser_elo)]
)[order(player_id,tourney_date,match_num)]
# take last match they played for each tourney_date
final_match <- temp3[,.SD[.N],by=.(player_id,tourney_date)][,match_num := NULL][order(player_id,-tourney_date)]
final_match[,tourney_date2 := as.Date(tourney_date,"%y-%m-%d")]
# from tourney_date to next row tourney_date - 1 day
# identify first and last records
elo_history <- final_match[, num_matches := .N, by = .(player_id)][
, match_num := seq_len(.N), by = .(player_id)][
, first := ifelse(match_num == 1, TRUE, FALSE)][
, last := ifelse(match_num == num_matches, TRUE, FALSE)][
, lag_tourney_date := lag(tourney_date)][
, from_date := tourney_date][
, to_date := as.Date(ifelse(first,as.Date("31dec9999","%d%b%Y"),lag_tourney_date),origin="1970-01-01")][
order(player_id,from_date,to_date),.(tourney_id,tourney_date,player_id,from_date,to_date,elo)]
# remove working datasets
rm(elo.input.data,temp2,temp3,final_match,output,temp)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
print("Done!")
library(dplyr);library(lubridate);library(data.table)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
# load tennis data, remove what we don't need
source("load_data.R")
rm(list=setdiff(ls(),list('match.data','player.data','Data')))
lapply(list(Data,match.data,player.data),setDT)
match.data <- match.data[, .(tourney_id,tourney_date,match_num,winner_id,loser_id)]
# subset of data for matches played in 2019
elo.input.data <- match.data[year(tourney_date) %in% c(2000:2019)]
# a function that computes the elo points added/subtracted from the winner/loser following one match
elo.calculate.points <- function(arg.p1,
arg.p2,
arg.winner,
arg.p1.matches,
arg.p2.matches,
arg.prevelo.p1,
arg.prevelo.p2
) {
# calculate the pre-match win probabilities of each player on the day of the match
e_p1 <- 1/(1 + 10^((arg.prevelo.p2 - arg.prevelo.p1)/400))
e_p2 <- 1/(1 + 10^((arg.prevelo.p1 - arg.prevelo.p2)/400))
# create the k factor for the winner and loser (depends on prior number of matches)
k_p1 <- 250/((arg.p1.matches + 5)^0.4)
k_p2 <- 250/((arg.p2.matches + 5)^0.4)
# actual outcome for winner and loser
if(arg.winner == arg.p1) {
s_p1 <- 1
s_p2 <- 0
} else {
s_p1 <- 0
s_p2 <- 1
}
# update elo for players
elo_p1 <- round(arg.prevelo.p1 + k_p1*(s_p1 - e_p1),0)
elo_p2 <- round(arg.prevelo.p2 + k_p2*(s_p2 - e_p2),0)
# return new elo points of player 1 and 2 respectively
return(list(elo_p1,elo_p2))
}
# sort data by tourney_date and match_num
temp <- elo.input.data[order(tourney_date,tourney_id,match_num)]#[c(1:10),]
# vectors for players and their current Elo ratings
players <- unique(c(elo.input.data[['winner_id']],elo.input.data[['loser_id']]))
elo <- rep(1500,length=length(players))
matches <- rep(0,length(players))
# go through match-by-match, updating Elos for each player
output <- apply(
temp,
MARGIN = 1,
function(x) {
# determine indices for winner and loser
winner <- which(players==x[4])
loser <- which(players==x[5])
# calculate winner and loser Elo points
points <- elo.calculate.points(
arg.p1 = x[4],
arg.p2 = x[5],
arg.winner = x[4],
arg.p1.matches = matches[winner],
arg.p2.matches = matches[loser],
arg.prevelo.p1 = elo[winner],
arg.prevelo.p2 = elo[loser]
)
# update matches count
matches[winner] <<- matches[winner] + 1
matches[loser] <<- matches[loser] + 1
# update Elos
elo[winner] <<- points[[1]]
elo[loser] <<- points[[2]]
# output
return(points)
}
)
print("Elos calculated")
# extract values and put these into the data
temp2 <- temp[,`:=`(
winner_elo = unlist(output)[c(TRUE,FALSE)],
loser_elo = unlist(output)[c(FALSE,TRUE)]
)][order(tourney_date,tourney_id,match_num)]
# sadly we do not know the date of each actual match
# this means that the best we can do is do store the
# Elo ratings for each player for the final match of
# each tournament he/she played in
# so we will take this match now
# first we need to convert the data to one row per player/match
temp3 <- rbind(
copy(temp2)[,.(tourney_id,tourney_date,match_num,player_id=winner_id,elo=winner_elo)],
copy(temp2)[,.(tourney_id,tourney_date,match_num,player_id=loser_id,elo=loser_elo)]
)[order(player_id,tourney_date,match_num)]
# take last match they played for each tourney_date
final_match <- temp3[,.SD[.N],by=.(player_id,tourney_date)][,match_num := NULL][order(player_id,-tourney_date)]
final_match[,tourney_date2 := as.Date(tourney_date,"%y-%m-%d")]
# from tourney_date to next row tourney_date - 1 day
# identify first and last records
elo_history <- final_match[, num_matches := .N, by = .(player_id)][
, match_num := seq_len(.N), by = .(player_id)][
, first := ifelse(match_num == 1, TRUE, FALSE)][
, last := ifelse(match_num == num_matches, TRUE, FALSE)][
, lag_tourney_date := lag(tourney_date)][
, from_date := tourney_date][
, to_date := as.Date(ifelse(first,as.Date("31dec9999","%d%b%Y"),lag_tourney_date),origin="1970-01-01")][
order(player_id,from_date,to_date),.(tourney_id,tourney_date,player_id,from_date,to_date,elo)]
# remove working datasets
rm(elo.input.data,temp2,temp3,final_match,output,temp,elo,matches,players)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
print("Done!")
library(dplyr);library(lubridate);library(data.table)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
return(list(winners,results_df))
}
x <- snapshot(elo_history,"2019-06-01")
y <- as.character(x$player_id)
z <- sample(y,size=32,replace=F)
library(dplyr);library(lubridate);library(data.table)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
library(dplyr);library(lubridate);library(data.table)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
return(list(winners,results_df))
}
x <- snapshot(elo_history,"2019-06-01")
y <- as.character(x$player_id)
z <- sample(y,size=32,replace=F)
output <- lapply(rep(1,10),simulate_tournament("2019-06-01",z)[[2]])
output <- replicate(10,simulate_tournament("2019-06-01",z)[[2]])
View(output)
output <- replicate(10,simulate_tournament("2019-06-01",z)[[2]])
View(output)
simulate_tournament("2019-06-01",z)[[2]]
# how long to run function 100 times?
output <- replicate(10,simulate_tournament("2019-06-01",z)[[1]])
# how long to run function 100 times?
output <- replicate(100,simulate_tournament("2019-06-01",z)[[1]])
output <- replicate(1000,simulate_tournament("2019-06-01",z)[[1]])
# how long to run function 100 times?
output <- replicate(1000,simulate_tournament("2019-06-01",z)[[1]])
print("Done")
start_time <- Sys.time()
output <- replicate(10000,simulate_tournament("2019-06-01",z)[[1]])
end_time <- Sys.time()
end_time-start_time
start_time <- Sys.time()
output <- replicate(1000,simulate_tournament("2019-06-01",z)[[1]])
end_time <- Sys.time()
end_time-start_time
start_time <- Sys.time()
output <- replicate(10000,simulate_tournament("2019-06-01",z)[[1]])
end_time <- Sys.time()
end_time-start_time
library(dplyr);library(lubridate);library(data.table)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
return(list(winners,results_df))
}
# example of running the function
# get some players
x <- snapshot(elo_history,"2019-06-01")
y <- as.character(x$player_id)
z <- sample(y,size=32,replace=F)
# function
#output <- simulate_tournament("2019-06-01",z)[[2]] # full dataset of tournament
# how long to run function 100 times?
#start_time <- Sys.time()
#output <- replicate(1000,simulate_tournament("2019-06-01",z)[[1]])
#end_time <- Sys.time()
#end_time-start_time
install.packages("EXTRAFONTS")
install.packages("extrafont")
library(extrafont)
