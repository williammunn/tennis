}
# update set_df data frame
game_df['game_number'] <- p1_games + p2_games
game_df['tiebreak_ind'] <- tiebreak
set_df <- rbind(
set_df,
game_df
)
}
}
if (p1_games > p2_games) {
set_winner <- 'P1'
} else {
set_winner <- 'P2'
}
return(list(set_winner,set_df,set_most_recent_server))
}
# define play_game
play_game <- function(arg_game_server,
arg_game_serve_pct,
arg_game_inherit = FALSE,
arg_game_inherited_score = NULL) {
# initial values
p1_points <- 0
p2_points <- 0
current_server <- arg_game_server
game_over <- FALSE
# inherit
if (arg_game_inherit) {
inherited_score <- convert_score(arg_game_inherited_score)
p1_points <- inherited_score[["p1_points"]]
p2_points <- inherited_score[["p2_points"]]
}
# this function additionally outputs a data frame with a record of points and their outcomes
game_df <- data.frame(
point_number = numeric(),
server = character(),
winner = character()
)
# play points until the game is over
while(game_over == FALSE) {
# play a point
point_winner <- play_point(arg_point_server = current_server,
arg_point_serve_pct = arg_game_serve_pct)
# increment points of the winner of the point just played
if (point_winner == 'P1') {
p1_points <- p1_points + 1
} else {
p2_points <- p2_points + 1
}
if (p1_points == 4 & p2_points == 4) {
p1_points <- 3
p2_points <- 3
}
# add a row to the game_df data frame
game_df <- rbind(
game_df,
data.frame(point_number = p1_points + p2_points, server = arg_game_server, winner = point_winner)
)
# check if the game is over
if ((p1_points >= 4 | p2_points >= 4) &
(abs(p1_points - p2_points) >= 2)) {
game_over <- TRUE
}
}
if (p1_points > p2_points) {
game_winner <- 'P1'
} else {
game_winner <- 'P2'
}
return(list(game_winner,game_df))
}
# define play_point
play_point <- function(arg_point_server,
arg_point_serve_pct) {
# generate random number
random_number <- runif(1)
# determine winner of point
if (arg_point_serve_pct > random_number) {
if (arg_point_server == 'P1') {
return('P1')
} else if (arg_point_server == 'P2') {
return('P2')
}
} else {
if (arg_point_server == 'P1') {
return('P2')
} else if (arg_point_server == 'P2') {
return('P1')
}
}
}
play_tiebreak <- function(arg_tiebreak_first_server,
arg_tiebreak_p1_serve_pct,
arg_tiebreak_p2_serve_pct,
arg_tiebreak_inherit=FALSE,
arg_tiebreak_inherited_score=NULL) {
# initial values
tiebreak_over <- FALSE
tiebreak_current_server <- arg_tiebreak_first_server
p1_points <- 0
p2_points <- 0
tiebreak_serves_remaining <- 1 # first person to serve only serves once
# inherit
if (arg_tiebreak_inherit) {
inherited_score <- convert_score(arg_tiebreak_inherited_score)
p1_points <- inherited_score[["p1_points"]]
p2_points <- inherited_score[["p2_points"]]
tiebreak_server_points_served <- (sum(p1_points,p2_points)%%2) + 1
}
# this function additionally outputs a data frame with the outcomes of individual points
tiebreak_df <- data.frame(
point_number = numeric(),
server = character(),
winner = character()
)
# play the remainder of the tiebreak
while(tiebreak_over == FALSE) {
# play the current server's 2 points
while (tiebreak_serves_remaining > 0) {
# play the first point on this player's server
point_winner <- play_point(arg_point_server = tiebreak_current_server,
arg_point_serve_pct = ifelse(tiebreak_current_server == 'P1',arg_tiebreak_p1_serve_pct,arg_tiebreak_p2_serve_pct))
# award point to the winner
if (point_winner == 'P1') {
p1_points <- p1_points + 1
} else {
p2_points <- p2_points + 1
}
# increment the points served by this current server
tiebreak_serves_remaining <- tiebreak_serves_remaining - 1
# update the tiebreak_df object
tiebreak_df <- rbind(
tiebreak_df,
data.frame(point_number = p1_points + p2_points, server = tiebreak_current_server, winner = point_winner)
)
# check if tiebreak should be ended
if ((p1_points >= 7 | p2_points >= 7) & (abs(p1_points - p2_points) > 1)) {
tiebreak_over <- TRUE
break
}
}
# after the first point players get 2 serves each
tiebreak_serves_remaining <- 2
# swap server
tiebreak_current_server <- ifelse(tiebreak_current_server == "P1","P2","P1")
}
# determine who wins the tiebreak
if (p1_points > p2_points) {
tiebreak_winner <- 'P1'
} else {
tiebreak_winner <- 'P2'
}
# return the winner of the tiebreak
return(list(tiebreak_winner,tiebreak_df))
}
# example of a match
play_match(arg_best_of = 3, arg_match_first_server = 'P1', arg_match_p1_serve_pct = 0.9, arg_match_p2_serve_pct = 0.9)[[1]]
# example of a match
play_match(arg_best_of = 3, arg_match_first_server = 'P1', arg_match_p1_serve_pct = 0.9, arg_match_p2_serve_pct = 0.9)[[2]]
# convert a string representing the score into numeric variables
convert_score <- function(arg_score_string,arg_completed) {
# initial values
p1_games <- 0
p2_games <- 0
p1_total_games <- 0
p2_total_games <- 0
p1_total_tiebreaks <- 0
p2_total_tiebreaks <- 0
p1_points <- 0
p2_points <- 0
score_indexes <- c(0,sapply(gregexpr(pattern = " ", arg_score_string)[[1]], FUN = function(x) {x+1}))
scores <- character(length(score_indexes)-1)
for (i in 1:length(score_indexes)) {
scores[i] <- substr(arg_score_string,score_indexes[i],ifelse(is.na(score_indexes[i+1]-2),nchar(arg_score_string),score_indexes[i+1]-2))
} ; rm(i)
# if the match is not completed, the last element of 'scores' won't a set
if (!arg_completed) {
num_sets <- length(score_indexes)-1
num_completed_sets <- num_sets-1
} else{
num_sets <- length(score_indexes)
num_completed_sets <- num_sets
}
# function to get the winner of each completed set
get_set_winner <- function(arg_set_string) {
p1_games <- as_integer(substr(arg_set_string,1,1))
p2_games <- as_integer(substr(arg_set_string,3,3))
if ((p1_games == 6 & p2_games < 5) | (p1_games == 7)) {
return(list("P1",p1_games,p2_games))
} else if ((p2_games == 6 & p1_games < 5) | (p2_games == 7)) {
return(list("P2",p1_games,p2_games))
} else {
return("error")
}
}
# retrieve winners of completed sets
set_winners <- character(num_completed_sets)
if (num_completed_sets > 0) {
for (set_num in 1:num_completed_sets) {
set_winners[set_num] <- get_set_winner(scores[set_num])[[1]]
p1_total_games <- p1_total_games + min(6,get_set_winner(scores[set_num])[[2]])
p2_total_games <- p2_total_games + min(6,get_set_winner(scores[set_num])[[3]])
p1_total_tiebreaks <- p1_total_tiebreaks + ifelse(get_set_winner(scores[set_num])[[2]]==7,1,0)
p2_total_tiebreaks <- p2_total_tiebreaks + ifelse(get_set_winner(scores[set_num])[[3]]==7,1,0)
}
}
# extract number of completed sets won
p1_sets <- sum(set_winners == "P1")
p2_sets <- sum(set_winners == "P2")
rm(set_num,set_winners)
# get the number of games in the current set, if there is an uncompleted set
if (!arg_completed) {
p1_games <- as_integer(substr(scores[num_sets],1,1))
p2_games <- as_integer(substr(scores[num_sets],3,3))
p1_total_games <- p1_total_games + p1_games
p2_total_games <- p2_total_games + p2_games
}
# determine if a tiebreak is currently happening
if(p1_games == 6 & p2_games == 6) {
tiebreak_ind <- TRUE
} else {
tiebreak_ind <- FALSE
}
# index of "-" for points
if (!arg_completed) {
dash_index <- gregexpr(pattern = "-", scores[length(scores)])[[1]]
# get the number of points in the current game, depends
p1_points <- substr(scores[length(scores)],1,dash_index-1)
p2_points <- substr(scores[length(scores)],dash_index+1,nchar(scores[length(scores)]))
# if not a tiebreak then need to convert scores like 40 and 30 to integer number of points
if(!(tiebreak_ind)) {
p1_points <- switch(p1_points,
"0" = 0,
"15" = 1,
"30" = 2,
"40" = 3,
"Ad" = 4)
p2_points <- switch(p2_points,
"0" = 0,
"15" = 1,
"30" = 2,
"40" = 3,
"Ad" = 4)
}
p1_points <- as_integer(p1_points)
p2_points <- as_integer(p2_points)
}
return(list("p1_sets" = p1_sets,
"p2_sets" = p2_sets,
"p1_games" = p1_games,
"p2_games" = p2_games,
"p1_points" = p1_points,
"p2_points" = p2_points,
"tiebreak_ind" = tiebreak_ind,
"p1_total_games" = p1_total_games,
"p2_total_games" = p2_total_games,
"p1_total_tiebreaks" = p1_total_tiebreaks,
"p2_total_tiebreaks" = p2_total_tiebreaks))
}
rounds <- 3
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
rm(list=ls())
library(dplyr);library(lubridate);library(data.table);library(sqldf)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
# output
return(list(winners,results_df))
}
# example of running the function
# get some players
x <- snapshot(elo_history,"2019-06-01")
y <- as.character(x$player_id)
z <- sample(y,size=32,replace=F)
# function
output <- simulate_tournament("2022-01-01",z)[[2]] # full dataset of tournament
rm(list=ls())
library(dplyr);library(lubridate);library(data.table);library(sqldf)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
rm(list=ls())
library(dplyr);library(lubridate);library(data.table);library(sqldf)
setwd("/Users/williammunn/Documents/Github/tennis/functions")
source("load_data.R")
source("functions.R")
source("elo.R")
simulate_tournament <- function(
tournament_date,
player_list
) {
# ensure there are no duplicates on the players list
if(sum(duplicated(player_list))>0) {
stop("Remove duplicates on your player_list")
}
# look up elo ratings from elo_history dataset
players  <- as.character(snapshot(elo_history,tournament_date)$player_id)
# ensure all players on player_list exist in the snapshot
players_in_player_list <- players[players %in% player_list]
if(length(player_list) != length(players_in_player_list)) {
stop("Not all players in your list have Elo ratings")
}
# get elos in same order as players appear in player_list
elos <- as.numeric(snapshot(elo_history,tournament_date)$elo)[players %in% player_list]
players <- players_in_player_list
# determine number of rounds
# if there are too few players in the list (i.e. not a power of 2)
# then the function will fill in the blanks with byes
rounds <- log(length(players))/log(2)
if (rounds%%1 != 0) {
rounds <- ceiling(rounds)
}
# insert byes randomly into players and elos vector
# dataset for results
results_df <- data.frame(
match_num = numeric(length=(2^rounds)-1),
player1 = character(length=(2^rounds)-1),
player2 = character(length=(2^rounds)-1),
round = numeric(length=(2^rounds)-1),
elo1 = numeric(length=(2^rounds)-1),
elo2 = numeric(length=(2^rounds)-1),
winner = character(length=(2^rounds)-1)
)
# generate sequences to keep track of who should play who
for (x in 1:rounds) {
assign(paste0("id_round",x),rep(1:((2^rounds)/(2^x)),each=(2^x)))
}
# need temp vectors for players and elos that can reduce in size
players_tmp <- players
elos_tmp <- elos
matches_played <- 0
# play matches for each round
for (round in 1:rounds) {
# make life easier
id_round <- paste0("id_round",round)
id_round_val <- get(id_round)
# player id's
ids1 <- players_tmp[!duplicated(id_round_val)]
ids2 <- players_tmp[duplicated(id_round_val)]
# elos
elos1<- elos_tmp[!duplicated(id_round_val)]
elos2 <- elos_tmp[duplicated(id_round_val)]
# play each other
outcomes <- mapply(elo_outcome,elos1,elos2)
winners <- character(length(outcomes))
for(i in 1:length(outcomes)) {
if(outcomes[i] > runif(1)) {
winners[i] <- ids1[i]
} else {
winners[i] <- ids2[i]
}
}
# update rows in the results_df data frame
for (i in 1:length(outcomes)) {
results_df$match_num[matches_played+i] <- matches_played+i
results_df$player1[matches_played+i] <- ids1[i]
results_df$player2[matches_played+i] <- ids2[i]
results_df$round[matches_played+i] <- round
results_df$elo1[matches_played+i] <- elos1[i]
results_df$elo2[matches_played+i] <- elos2[i]
results_df$winner[matches_played+i] <- winners[i]
}
# how many matches have now been player in total?
matches_played <- matches_played + length(outcomes)
# players_tmp and elos_tmp get reduced to reflect only winners
elos_tmp <- elos_tmp[players_tmp %in% winners]
players_tmp <- players_tmp[players_tmp %in% winners]
# if not the final round
# we need to remove the loser entries
# from the next id_round vector
if(round != rounds) {
tmp <- get(paste0("id_round",round+1))
tmp <- tmp[players %in% winners]
# replace id_round(X+1) with tmp
assign(paste0("id_round",round+1),tmp)
}
}
# output
return(list(winners,results_df))
}
x <- snapshot(elo_history,"2019-06-01")
y <- as.character(x$player_id)
z <- sample(y,size=32,replace=F)
# function
output <- simulate_tournament("2022-01-01",z)[[2]] # full dataset of tournament
View(output)
# add on player name
player <- player.data
output2 <- sqldf(
"select a.*,
b.player_name as name1,
c.player_name as name2,
d.player_name as winner_name
from output a
left join player b on a.player1 = b.player_id
left join player c on a.player2 = c.player_id
left join player d on a.winner = d.player_id")
player <- player_data
output2 <- sqldf(
"select a.*,
b.player_name as name1,
c.player_name as name2,
d.player_name as winner_name
from output a
left join player b on a.player1 = b.player_id
left join player c on a.player2 = c.player_id
left join player d on a.winner = d.player_id")
View(output2)
start_time <- Sys.time()
output <- replicate(1000,simulate_tournament("2019-06-01",z)[[1]])
end_time <- Sys.time()
end_time-start_time
View(elo_history)
